// Compile command: gcc 03.2-contar-args.c -o 03.2-contar-args.out

// The EOF marker is a signal that there is no more data to be read from the input stream.
// It is typically generated by the operating system or the terminal environment when you
//      indicate the end of input through a special key combination or command,
//      such as Ctrl+D (on Unix-like systems) or Ctrl+Z (on Windows).

// fgets() is generally considered safer than gets() because it allows you to specify
//      the maximum number of characters to read and prevents buffer overflow vulnerabilities.
//      Additionally, fgets() provides more control over the handling of newline characters
//      in the input string. Therefore, it's recommended to use fgets() instead of gets()
//      for reading strings from stdin in C programs.
    
#include <stdio.h>
#include <ctype.h>
#include <string.h>     // for strlen()
#include <stdlib.h>     // needed for malloc();

// Uma sequência de caracteres brancos
int ReadWord_1(FILE *f, char *s)
{
    int c;
    while (c = getc(f), !isspace(c))
        *s++ = c;
    *s = '\0';
    return ungetc(c, f);    // Puts back the last read char and returns c
}

// Uma sequência de letras e hífenes
int ReadWord(FILE *f, char *s)
{
    int c;
    while (c = getc(f), isalpha(c) || c == '-')
        *s++ = c;
    *s = '\0';
    return ungetc(c, f);    // c is forgoten and thus needs to be given
}

// Uma sequência de letras, algarismos e sublinhados
int ReadWord_3(FILE *f, char *s)
{
    int c;
    while (c = getc(f), isalnum(c) || c == '_')
        *s++ = c;
    *s = '\0';
    return ungetc(c, f);
}

// Para uma sequência de letras e hífenes
int SkipChars(FILE *f, int *n)
{
    int c;
    int k = 0;
    while ((c = getc(f)) != '\n' &&
           (isspace(c) || isdigit(c) ||
            ispunct(c) && c != '-'))
        k++;
    *n = k;
    return ungetc(c, f);
}

#define MAX_WORDS 1024
char *words[MAX_WORDS];
long n_words;
long n_unique;

//char *ExistsWord(char *s)
//{
    //char **p;
    //for (p = words; *p != NULL && strcmp(*p, s); p++) {}
    //return *p;
//}

char *strnew(const char *s)
{
    //                                    + 1 is the extra char for '\0'
    return strcpy((char*)malloc(strlen(s) + 1), s);
}

typedef struct {
    char *word;
    int count;
} Counter;

#define MAX_WORDS 1024
Counter *counters[MAX_WORDS];
int n_counters;

Counter *NewCounter(char *s)
{
    Counter *x = (Counter *)malloc(sizeof(Counter));
    x->word = strnew(s);
    x->count = 1;
    return x;
}

Counter *ExistsWord(char *s)
{
    Counter **p;    // Array of pointers
    
    for (p = counters; *p != NULL && strcmp((**p).word, s); p++) {}
    
    return *p;
}

void SortPointers(void **v, size_t n, int(*f)(const void *, const void *))
{
    void *m;
    for (size_t i = 1; i < n; i++)
        for (size_t j = n - 1; j >= i; j--)
            if (!f(v[j - 1], v[j]))
            {
                m = v[j - 1];
                v[j - 1] = v[j];
                v[j] = m;
            }
}

void SortCounters(int(*f)(const Counter *, const Counter *))
{
    SortPointers((void **) counters, n_counters,
                 (int(*)(const void *, const void *)) f);
}

int ltbyword(const Counter *x, const Counter *y)
{
    return strcmp(x->word, y->word) <= 0;
}

int ltbycount(const Counter *x, const Counter *y)
{
    return x->count >= y->count || x-> count == y->count && ltbyword(x, y);
}

void PrintCounter(const Counter *p)
{
    printf("%-24s %4d\n", p->word, p->count);
}

void IteratePointers(void **v, size_t n, void(*f)(void *))
{
    while (n--)
        f(*v++);
}

void PrintCounters(void)
{
    IteratePointers((void **) counters, n_counters, (void(*)(void *)) PrintCounter);
}

typedef enum {byword, bycount} SortCriterium;

void CopyOne(FILE *g, FILE *f)
{
    char c;
    while ((c = getc(f)) != EOF)
        putc(c, g);
}

#define UNABLE_TO_READ  1
#define UNABLE_TO_WRITE 2

int main(int argc, char **argv)
{
    SortCriterium sortby = byword;
    
    FILE *g, *f;
                // left to right priority of * and ++
    if ((g = fopen(*++argv, "w")) == NULL)
        return UNABLE_TO_WRITE;
    argc--;
    
    while (--argc)
    {
        // Can't definitly increase here
        if (**(argv + 1) == '-')
        {
            argv++;
            //      Moves to next char after '-', not next arg!
            switch (*++*argv)
            {
                case 'a':
                    sortby = byword;
                    break;
                case 'f':
                    sortby = bycount;
                    break;
                default:
                    sortby = byword;
                    break;
            }
        }
        else if ((f = fopen(*++argv, "r")) == NULL)
        {
            fclose(g);
            return UNABLE_TO_READ;
        }
        CopyOne(g, f);
        fclose(f);
    }
    fclose(g);
    
    return 0;
}

